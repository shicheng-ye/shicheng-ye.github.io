<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Yourname"><title>Hexo</title><meta name="description" content="A simple and beautiful blog"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>A simple and beautiful blog</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Lhcfl"><i class="fa fa-github"></i></a></li><li><a href="mailto:yourname@example.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/jin-xin-4-68"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Yourname</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/07/06/machine-learning/2022-07-06-review-generative-adversarial-network.md/">generative-adversarial-network</a></h3></div><div class="post-content"><div class="card"><p><h1 id="GAN-P1"><a href="#GAN-P1" class="headerlink" title="GAN_P1"></a>GAN_P1</h1><h1 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h1><h2 id="Network-as-Generator"><a href="#Network-as-Generator" class="headerlink" title="Network as Generator"></a>Network as Generator</h2><p>输入 x 和从一个distribution 裡面 sample 出来的 z，输出变成了一个复杂的 distribution。这种输出 distribution 的 network 称之为&#x3D;&#x3D;generator&#x3D;&#x3D;。</p>
<img src="https://s2.loli.net/2022/07/02/eDOx7rbhcL9BEZA.png" alt="image-20220702205648601" style="zoom:50%;" />

<h2 id="Why-distribution"><a href="#Why-distribution" class="headerlink" title="Why distribution"></a>Why distribution</h2><p>为什么要输出一个分布？有时候需要这样。</p>
<p>例子：video prediction，即给机器一段的影片，然后它要预测接下来会发生什麼事情。训练资料裡面同样的输入，有时候同样的转角有两种可能性。所以你的 network 学到的就是两面讨好。</p>
<p>什麼时候我们会特别需要这？我们的任务需要一点创造力的时候。通俗讲，们想要找一个function，但是同样的输入有多种可能的输出，他们都是对的。</p>
<h1 id="Generative-Adversarial-Network-GAN"><a href="#Generative-Adversarial-Network-GAN" class="headerlink" title="Generative Adversarial Network (GAN)"></a>Generative Adversarial Network (GAN)</h1><p>generative 的 model，其中一个非常知名的就是&#x3D;&#x3D;generative adversarial network&#x3D;&#x3D;。</p>
<h2 id="Anime-Face-Generation"><a href="#Anime-Face-Generation" class="headerlink" title="Anime Face Generation"></a>Anime Face Generation</h2><p>例子：让机器生成动画人物的,二次元人物的脸。</p>
<img src="https://s2.loli.net/2022/07/02/jlqBn7UevwaStmH.png" alt="image-20220702210030736" style="zoom: 50%;" />



<h2 id="Discriminator"><a href="#Discriminator" class="headerlink" title="Discriminator"></a>Discriminator</h2><p>在GAN裡面除了&#x3D;&#x3D;generator&#x3D;&#x3D;以外还有一个 &#x3D;&#x3D;discriminator&#x3D;&#x3D;。</p>
<p>discriminaton 也是个 network，它的作用是：拿一张图片作為输入，它的输出是一个数值。越大代表越像是真实的二次元图像。 </p>
<h2 id="Basic-Idea-of-GAN"><a href="#Basic-Idea-of-GAN" class="headerlink" title="Basic Idea of GAN"></a>Basic Idea of GAN</h2><p>物竞天择。对应到 GAN，枯叶蝶就是 generator，那它的天敌就是 discriminator。</p>
<p>generator 生成二次元图像。discriminator 分辨二次元图像。</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h4 id="Step-0：初始化-generator-和-discriminator-的参数。"><a href="#Step-0：初始化-generator-和-discriminator-的参数。" class="headerlink" title="Step 0：初始化 generator 和 discriminator 的参数。"></a>Step 0：初始化 generator 和 discriminator 的参数。</h4><h4 id="Step-1-Fix-generator-G-and-update-discriminator-D"><a href="#Step-1-Fix-generator-G-and-update-discriminator-D" class="headerlink" title="Step 1: Fix generator G, and update discriminator D"></a>Step 1: Fix generator G, and update discriminator D</h4><p>从这个 gaussian distribution 裡面去 sample 一堆 vector，把这些 vector 丢到 generator 裡面，它就吐出一些图片。</p>
<p>你会有一个 database，这个database裡面，有很多二次元人物的头像。</p>
<p>接下来就拿真正的二次元人物头像，跟 generator 產生出来的结果，去训练你的discriminator。discriminator 它训练的目标是要分辨，真正的二次元人物跟 generator 產生出来的二次元人物。</p>
<p>这对於 discriminator 来说是一个分类的问题。也可以说是 regression 的问题。</p>
<img src="https://s2.loli.net/2022/07/02/yVjMHO91l8wvBYd.png" alt="image-20220702211803640" style="zoom:50%;" />

<h4 id="Step-2-Fix-discriminator-D-and-update-generator-G"><a href="#Step-2-Fix-discriminator-D-and-update-generator-G" class="headerlink" title="Step 2: Fix discriminator D, and update generator G"></a>Step 2: Fix discriminator D, and update generator G</h4><p>我们把 generator 生成的图片丢到 Discriminator 裡面，Discriminator 会给这个图片一个分数，那 generator 是要 Discriminator 的输出值越大越好</p>
<p>举例来说 generator 如果是五层的 network，Discriminator 如果是五层的 network，把它们接起来我们就把它当作是一个十层的 network 来看待。这个十层的network裡面，其中某一隐藏层的输出就是代表一张图片。</p>
<p>我们要做的事情是,整个巨大的 network 啊,它会吃一个向量作為输入，然后他会输出一个分数,那我们希望调整这个 network，让输出的分数越大越好。&#x3D;&#x3D;gradient ascent&#x3D;&#x3D; 来优化。</p>
<img src="https://s2.loli.net/2022/07/02/pohEWjL1BzN692T.png" alt="image-20220702211815139" style="zoom:50%;" />





<h1 id="GAN-P2-Theory-behind-GAN"><a href="#GAN-P2-Theory-behind-GAN" class="headerlink" title="GAN_P2_Theory behind GAN"></a>GAN_P2_Theory behind GAN</h1><p>接下来讨论為什麼这个 Generator 跟 Discriminator 的互动，可以让我们的 Generator產生像是真正的人脸的图片。</p>
<p>那我们先来弄清楚训练的目标到底是什麼，我们想要 Minimize 的是让 Generator 产生的 Distribution 和 真正 Data 的 Distribution 越接近越好。</p>
<img src="https://s2.loli.net/2022/07/02/SrRm7qka3Gznywl.png" alt="image-20220702212331965" style="zoom:50%;" />

<p>Div &#x3D; Divergence。红色下划线的函数也就表示了我们的 Loss Function。</p>
<p>常见的 Divergence 计算方法：</p>
<img src="https://s2.loli.net/2022/07/02/NcdJfC34mDreIQa.png" alt="image-20220702212648534" style="zoom:50%;" />

<img src="C:%5CUsers%5Cysc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220702212653606.png" alt="image-20220702212653606" style="zoom:50%;" />



<p>但是我们这边遇到一个困难的问题，这个 Divergence 很难算的。而&#x3D;&#x3D;GAN&#x3D;&#x3D;是一个很神奇的做法,它&#x3D;&#x3D;可以突破,我们不知道怎麼计算 Divergence 的限制&#x3D;&#x3D;。</p>
<p>我们不需要知道 PG 跟 Pdata 它们实际上的 Formulation （对应公式的 P(x) 和 Q(x)）长什麼样子，只要能从 PG 和 Pdata这两个 Distributions Sample 东西出来，就有办法算 Divergence。</p>
<h2 id="Discriminator-1"><a href="#Discriminator-1" class="headerlink" title="Discriminator"></a>Discriminator</h2><p>如何在只有做 Sample 的前提之下估测出 Divergence？那这个就是要靠 &#x3D;&#x3D;Discriminator&#x3D;&#x3D; 的力量。</p>
<p>Discriminator 优化的过程，你也可以把它写成式子：</p>
<img src="https://s2.loli.net/2022/07/02/r865BCpik9Ihtlc.png" alt="image-20220702213617546" style="zoom:50%;" />

<p>这个 Discriminator 可以去 Maximize某一个 Function,我们这边叫做 &#x3D;&#x3D;Objective Function&#x3D;&#x3D;（我们要 Maximize 的东西,我们会叫 Objective Function,如果 Minimize 我们就叫它 Loss Function）。</p>
<ul>
<li><p>$E_{y\sim P_{data}}[logD(y)]$ 我们有一堆 Y,它是从 Pdata 裡面 Sample 出来的,也就是它们是真正的 Image,而我们把这个真正的 Image 丢到 D 裡面,得到一个分数再取$logD(y)$</p>
</li>
<li><p>$E_{y\sim P_G}[log(1-D(y))]$ 那另外一方面,我们有一堆 Y,它是从 PG 从 Generato r 所產生出来的,把这些图片也丢到 Discriminator 裡面,得到一个分数,再取 $log(1 - D (y))$</p>
</li>
</ul>
<p>那这边最神奇的地方是这一个式子，这个红框框裡面的数值,它跟 JS Divergence 有关。假设 PG 跟 Pdata 的 Divergence 很小，所以这个 Objective 这个 V 的 Maximum 的值就比较小。所以小的 Divergence，对应到小的这个 Objective Function 的Maximum 的值。</p>
<img src="C:%5CUsers%5Cysc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220702214350465.png" alt="image-20220702214350465" style="zoom:50%;" />



<h2 id="Tips-for-GAN"><a href="#Tips-for-GAN" class="headerlink" title="Tips for GAN"></a>Tips for GAN</h2><p>技巧之一： &#x3D;&#x3D;WGAN&#x3D;&#x3D;。</p>
<p>在此之前先讲 JS Divergence 有什麼样的问题。</p>
<h3 id="JS-divergence-is-not-suitable"><a href="#JS-divergence-is-not-suitable" class="headerlink" title="JS divergence is not suitable"></a>JS divergence is not suitable</h3><p>PG 跟 Pdata 有一个非常关键的特性是：它们重叠的部分往往非常少。</p>
<p>原因有二：其一，那图片其实是高维空间裡面的一个低维的 Manifold，二次元人物的头像它的分布在高维的空间中其实是非常狭窄的。其二，我们对 PG 跟 Pdata,它的分布的理解来自於 Sample，如果采样不全有重叠也发现不了。</p>
<p>JS Divergence 有个特性，是两个没有重叠的分布，JS Divergence 算出来,就永远都是 Log2。因此用 JS Divergence 的时候，你就假设你今天在 Train 一个 Binary 的 Classifier，你会发现实际上你通常 Train 完以后正确率几乎都是 100%。</p>
<p>因為你 Sample 的图片根本就没几张，它直接用硬背来分辨。所以这时候 accuracy 没啥用。</p>
<h3 id="Wasserstein-Distance"><a href="#Wasserstein-Distance" class="headerlink" title="Wasserstein Distance"></a>Wasserstein Distance</h3><p>假想你在开一台推土机,那你把分布 P 想成是一堆土，把分布 Q 想成是你要把土堆放的目的地，那这个推土机把 P 这边的土，挪到 Q 所移动的平均距离就是 Wasserstein Distance。</p>
<img src="https://s2.loli.net/2022/07/02/YbfdnjBgKyG7MiQ.png" alt="image-20220702215728448" style="zoom:50%;" />



<p>但是推土的办法有很多种。因此光只是要计算一个 Distance，居然还要解一个 Optimization 的问题，解出这个 Optimization 的问题，才能算 Wasserstein Distance。先讲 Wasserstein Distance 能给我们什么好处。</p>
<img src="https://s2.loli.net/2022/07/02/L2exJ7objlQV6RU.png" alt="image-20220702215942823" style="zoom:50%;" />



<p>由左向右的时候，Wasserstein Distance 是越来越小的，表明 Generator 在进步。JS Divergence 却不变。</p>
<h3 id="WGAN"><a href="#WGAN" class="headerlink" title="WGAN"></a>WGAN</h3><p>用 Wasserstein Distance 来取代 JS Divergence 的时候，这个 GAN 就叫做 WGAN。</p>
<p>接下来你会遇到的问题就是，Wasserstein Distance 是要怎麼算。</p>
<p>解下面这个 Opimilazion 的 Problem，解出来以后你得到的值就是 Wasserstein Distance。</p>
<img src="https://s2.loli.net/2022/07/02/BQdKpZU4hnojlkT.png" alt="image-20220702220447872" style="zoom:50%;" />

<p>即我们想要 Discriminator 对 Pdata 输出越大越好，对 PG 的 输出越小越好。 </p>
<p>限制：D 必须要是一个 1-Lipschitz 的 Function。</p>
<p>1-Lipschitz 不知道是什麼的话也没关係。可以想象成 D 必须要是一个足够平滑的 Function。</p>
<img src="https://s2.loli.net/2022/07/02/zW8YZsXSBRuwAIn.png" alt="image-20220702220721319" style="zoom:50%;" />

<p>否则，就会出现无限大的情况。这会导致要优化的目标越来越大，这下就又不能收敛力（悲。</p>
<p>接下来的问题就是怎麼做到 1-Lipschitz 的这个限制。</p>
<p>想法一：只需 Train Network 的时候，让 Training 的那个参数，要求它放得在 C 跟 -C 之间，如果参数更新后超过就设为 C 就设为 C，小于 -C 就设为 -C。但这样其实挺拉的。</p>
<p>想法二：Gradient Penalty。</p>
<img src="https://s2.loli.net/2022/07/02/5tfQYTE1ApIj9Zl.png" alt="image-20220702221255324" style="zoom:50%;" />

<p>想法三：Spectral Normalization。</p>
<h1 id="GAN-P3"><a href="#GAN-P3" class="headerlink" title="GAN_P3"></a>GAN_P3</h1><p>有了 WGAN 并不代表说 GAN 就一定特别好 Train。為什麼 GAN 很难被 Train 起来？</p>
<p>事实上 Generator 跟 Discriminator，它们是互相砥砺才能互相成长的，只要其中一者发生什麼问题停止训练，另外一者就会跟著停下训练。</p>
<h2 id="Conditional-Generation"><a href="#Conditional-Generation" class="headerlink" title="Conditional Generation"></a>Conditional Generation</h2><p>到目前為止我们讲的 Generator，它输入都是一个随机的分布而已，那这个不见得非常有用。</p>
<p>我们现在想要更进一步的是，我们可以操控 Generator 的输出，我们给它一个 Condition x，让它根据 x 跟 z 来產生 y，那这样的 Conditional Generation。</p>
<img src="https://s2.loli.net/2022/07/02/IRunVTbEJ5xdNUW.png" alt="image-20220702222211000" style="zoom:50%;" />

<p>普通的 &#x3D;&#x3D;GAN&#x3D;&#x3D; 不也是一个标量一个向量输入？</p>
<p>如果要做文字对图片的生成，它其实是一个 Supervised Learning 的问题。你需要一些 Label 的 Data，比如说红眼睛的人头像，才能够训练这种 Conditional 的 Generation。</p>
<p>所以在这样的任务裡面，我们的 x 就是一段文字。比如说输入 Red Eyes，然后机器就可以画一个红眼睛的角色，但每次画出来的角色都不一样。</p>
<p>也许你就可以去把 Generator 训练出来，但这样的方法是错误的。因为这样的 Generator 它只要產生清晰的图片，就可以骗过 Discriminator 了，它何必要去管 Input 文字叙述是什麼。</p>
<p>所以在 Conditional GAN 裡面， Discriminator 不是只吃图片 y，它还要吃 Condition x。</p>
<img src="C:%5CUsers%5Cysc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220702222850921.png" alt="image-20220702222850921" style="zoom:50%;" />



<p>那怎麼样训练这样的 Discriminator ？那你需要文字跟影像成对的资料，所以 Conditional GAN 一般的训练需要的 Data 的，是需要有标註的资料的。</p>
<p>光是这样子的 Positive Sample 还不够，还有 Negative Sample，即產生好的图片文字叙述配不上的状况。</p>
<p>再考虑 Image To Image 的情形，只是从影像產生影像,把文字的部分用影像取代掉而已。文献上如果你要做到最好，往往就是 GAN 跟 Supervised Learning，同时使用。</p>
<p>此外，输入的 label 也可以是 multi-label 的。</p>
<h1 id="GAN-P4-Learning-from-Unpaired-Data"><a href="#GAN-P4-Learning-from-Unpaired-Data" class="headerlink" title="GAN_P4 Learning from Unpaired Data"></a>GAN_P4 Learning from Unpaired Data</h1><p>最后讲一个GAN的神奇应用，它把GAN用在&#x3D;&#x3D;unsupervised Learning&#x3D;&#x3D;。</p>
<p>我们可能会遇到一个状况：我们有一堆 X 我们有一堆 Y，但 X 跟 Y 是不成对的。这叫做&#x3D;&#x3D;unlabeled&#x3D;&#x3D;的资料。</p>
<img src="https://s2.loli.net/2022/07/02/YJeNnvA8OHcTklV.png" alt="image-20220702223725028" style="zoom:50%;" />



<p>我们这边举一个例子：影像风格转换。X domain 是真人的照片，Y domain的图是二次元人物的头像。这个例子没有任何的成对的资料。</p>
<p>解决办法：Unsupervised Conditional Generation。</p>
<img src="https://s2.loli.net/2022/07/02/txUk6CiOclPKSsZ.png" alt="image-20220702224026202" style="zoom:50%;" />

<p>输入是一个 Gaussian 的分佈，输出可能是一个复杂的分佈。现在我们在稍微转换一下我们的想法，输入说是 X domain 的图片的分佈，输出说是 Y domain 的图片的分佈。</p>
<p>把输入改成  X domain 很简单，不从高斯分布里采样就行。那怎麼让输出变成是Y domain 的 distribution 呢？</p>
<p>那就要两三个 discriminator，那这个 discriminator 给它看过很多 Y domain 的图，所以它能够分辨 Y domain 的图跟不是 Y domain 的图。</p>
<img src="https://s2.loli.net/2022/07/03/xPShuYeZ5q1Fg9y.png" alt="image-20210524140458705" style="zoom:50%;" />

<p>但这样不够，还得保证生成的二次元头像跟输入的真实的照片有关联。</p>
<img src="https://s2.loli.net/2022/07/03/GZDRuk1986sXVa3.png" alt="image-20210524141004712" style="zoom:50%;" />



<p>由于没有成对数据，因此无法直接套用 conditional GAN 的想法。因為在 conditional GAN 裡面，我们是有成对的资料来训练 discriminator 的。</p>
<h2 id="Cycle-GAN"><a href="#Cycle-GAN" class="headerlink" title="Cycle GAN"></a>Cycle GAN</h2><p>这边这个想法叫做&#x3D;&#x3D;Cycle GAN&#x3D;&#x3D;。在Cycle GAN裡面会 train 两个 generator。</p>
<img src="https://github.com/unclestrong/DeepLearning_LHY21_Notes/blob/master/Notes_pic/image-20210524141830620.png?raw=true" alt="image-20210524141830620" style="zoom:50%;" />

<p>在训练的时候增加了一个额外的目标：希望输入一张图片，从 X domain 转成 Y domain 以后，要从Y domain转回原来的。我们要让原图和还原的图越相近越好。这叫做 &#x3D;&#x3D;Cycle的consistency&#x3D;&#x3D;。</p>
<p>两张图片本质上就是两个向量，它们之间的距离越接近越好，就是要两张图片越像越好。</p>
<p>所以现在这边我们有三个Network：</p>
<ol>
<li>第一个generator,它的工作是把X转成Y</li>
<li>第二个generator,它的工作是要把Y还原回原来的X</li>
<li>那这个discriminator,它的工作仍然是要看,蓝色的这个generator它的输出,像不像是Y domain的图</li>
</ol>
<p>这时你可能会有的一个问题就是：你只能保证两个 domain 的图有关系，但这种关系真的有意义？比如两个 generator 学到的都是图片反转，同样也能保证 cycle consistency。这个问题实际上一般不出现。</p>
<p>Cycle GAN 可以是双向的。</p>
<img src="https://s2.loli.net/2022/07/02/pMnYJsVlE2v49yf.png" alt="image-20220702225831039" style="zoom:50%;" />



<p>一些其他的 GAN。Disco GAN、Dual GAN 跟 Cycle GAN 没什么不同。</p>
<p>相比只能在两种风格间转换的 Cycle GAN，StarGAN 可以做多风格影像风格转换。</p>
<p>一些其他应用：把长的文章变成简短的摘要；翻译；非督导式的语音辨识。</p>
<h2 id="Evaluation-of-Generation"><a href="#Evaluation-of-Generation" class="headerlink" title="Evaluation of Generation"></a>Evaluation of Generation</h2><p>要评估 Generator 的好坏完全用人来看显然有很多的问题。应该来点客观的方法。</p>
<p>比如跑一个影像的分类系统：把你的 GAN 產生出来的图片，丢到一个的影像的分类系统裡面，看它產生什麼样的结果。</p>
<img src="https://s2.loli.net/2022/07/02/Dl2ynLFCiBHk1c3.png" alt="image-20220702230658786" style="zoom:50%;" />



<p>如果四不像，那就是均匀分布力。</p>
<h3 id="Diversity-Mode-Collapse"><a href="#Diversity-Mode-Collapse" class="headerlink" title="Diversity - Mode Collapse"></a>Diversity - Mode Collapse</h3><p>但是光用这个评估的方法会被一个叫做 &#x3D;&#x3D;Mode Collapse&#x3D;&#x3D; 的问题骗过去。</p>
<img src="https://s2.loli.net/2022/07/02/oSnfjz1grKa6QA4.png" alt="image-20220702230818845" style="zoom:50%;" />



<p>这会导致 Generative Model 输出来的图片来来去去就是那几张可能单一的图片。</p>
<p>那為什麼会有 Mode Collapse 这种现象发生？直觉上理解，这个地方就是 Discriminator 的一个盲点，发现这个盲点后每次都整这一出。</p>
<h3 id="Diversity-Mode-Dropping"><a href="#Diversity-Mode-Dropping" class="headerlink" title="Diversity - Mode Dropping"></a>Diversity - Mode Dropping</h3><p>但是有另外一种更难被侦测到的问题叫做 &#x3D;&#x3D;Mode Dropping&#x3D;&#x3D;。</p>
<p>Mode Dropping 的意思是说，你的產生出来的资料，但看起来多样性好像也够。</p>
<p>这种问题难以侦测。一种可能的方法：</p>
<p>借助我们的 Image Classifier。比如把 Generator 產生 1000 张图片，把这 1000 张图片裡,都丢到 Image Classify 裡面，看输出是哪个 class。</p>
<p>每张图片，都会给我们一个 Distribution。把所有图片的 Distribution 加起来平均，如果很集中说明多样性不行。</p>
<p>Diversity 跟 Quality 好像是有点互斥？实则不然。二者评估范围不同。Quality 是只看一张图片的分布，而 Diversity 看的是一堆图片它分布的平均。</p>
<p>过去有一个非常常被使用的分数,叫做 &#x3D;&#x3D;Inception Score&#x3D;&#x3D;。如果 Quality 高，那个 Diversity 又大，那 Inception Score 就会比较大。</p>
<h3 id="Frechet-Inception-Distance-FID"><a href="#Frechet-Inception-Distance-FID" class="headerlink" title="Fréchet Inception Distance (FID)"></a>Fréchet Inception Distance (FID)</h3><p>还有一个 Evaluation 的 Measure,叫 &#x3D;&#x3D;Fréchet Inception Distance&#x3D;&#x3D;。</p>
<img src="C:%5CUsers%5Cysc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220702233919606.png" alt="image-20220702233919606" style="zoom:50%;" />

<p>你先把你產生出来的二次元的人物，丢到 Inception Net 裡面，那个 Inception Network 输出它的类别，那你得到的可能就是人脸，那每一张二次元的人物看起来都是人脸，那我们不要拿那个类别。</p>
<p>我们拿进入 Softmax 之前的 Hidden Layer 的输出。把这个向量拿出来代表这张图片。</p>
<p>我们拿出来的是一个向量，而不是最后的类别。那虽然最后分类的类别可能是一样的，但是在决定最后的类别之前，这个向量就算都是人脸，可能还是不一样的。</p>
<p>假设真实的图片跟產生出来的图片它们都是 Gaussians 的 Distribution，然后去**计算这两个 Gaussians Distribution 之间的&#x3D;&#x3D;Fréchet  Distance&#x3D;&#x3D;**。因為它是一个 Distance，所以这个值就是越小越好，代表这两组图片越接近。</p>
<p>但实际上图片不一定是 Gaussians Distribution，且要準确得到你的 Network 它的分布需要產生大量的 Sample 才能做到。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-07-06</span><a class="tag" href="/categories/ml/" title="ml">ml </a><span class="leancloud_visitors"></span><span>About 4152 words, 13 min 50 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/07/06/machine-learning/2022-07-06-support-vector-machine/">support-vector-machine</a></h3></div><div class="post-content"><div class="card"><p><p>没有免费的午餐定理：在不考虑先验概率的情况下，所有算法的性能一样。即没有不存在适用于所有的问题的算法，不存在普适性的算法，任何两个算法，以及它们训练出来的模型，在所有的现实问题的集合面前是无优劣的，它们的性能的数学期望值是一样的。</p>
<p>尽管如此，适合大部分情况的算法依然是存在的。</p>
<p>线性可分（Linear Separable）：存在一条直线分开两类。线性不可分（Linear Unseparable）：反之。</p>
<p><img src="https://s2.loli.net/2022/05/31/w8QjIJaoXu4NWqL.png" alt="image-20220531150521269" style="zoom: 50%;" />                              <img src="https://s2.loli.net/2022/05/31/lhHLk8BOqdR6Kji.png" alt="image-20220531150559805" style="zoom:50%;" /></p>
<p>同样地，可以延伸至高维。用数学方式表示：</p>
<p><img src="https://s2.loli.net/2022/05/31/lNSTWmDonyPLdZr.png" alt="image-20220531150850968"></p>
<p>两侧正负号是人为定义的，将权重和偏置取反，两侧符号也便取反。</p>
<p>线性可分的严格定义：一个样本训练集 $${(X_i, y_i), …, (X_N,y_N)}$$ 在 i&#x3D;1-N 线性可分，是指存在 $$(w_1, w_2, b)$$ 使得对 i&#x3D;1-N，都有：</p>
<p>$$<br>(1)\ 若y_i&#x3D;+1, 则w_1x_{i1}+w_2x_{i2}+b&gt;0 \<br>(2)\ 若y_i&#x3D;-1, 则w_1x_{i1}+w_2x_{i2}+b&lt;0<br>$$</p>
<p>线性可分定义的简化形式：</p>
<p>如果 $$y_i$$ &#x3D; +1 或 -1，一个样本训练集 $${(X_i, y_i), …, (X_N,y_N)}$$ 在 i&#x3D;1-N 线性可分，是指存在 $$(w_1, w_2, b)$$ 使得对 i&#x3D;1-N，都有：</p>
<p>$$<br>y_i(w^TX_i+b)&gt;0<br>$$</p>
<p>课后思考：</p>
<p>① 你能否给出实际生活中训练样本集是线性可分和线性不可分的例子？大多数实际生活中的例子是线性可分还是线性不可分？</p>
<p>② 我们对于线性可分和线性不可分的定义只是局限于二分类间题，请对类别数大于 2 的情况，给出线性可分与线性不分严格的数学定义。</p>
<p>③ 请通过数学定义严格证明，在二分类情况下，如果一个数据集是线性可分的，那么一定存在无数多个超平面可以把这两个类别完全分开。</p>
<h3 id="线性可分的解法"><a href="#线性可分的解法" class="headerlink" title="线性可分的解法"></a>线性可分的解法</h3><p>支持向量机算法步骤：① 解决线性可分问题 ② 再将线性可分问题中获得的结论推广到线性不可分情况</p>
<p>例子：三种分割按照免费午餐定理应该都一样，为什么会觉得 2 比较好？因为建立在这样一个先验假设：训练样本的位置在特征空间上有测量误差，这样的话 2 会有更高的容错率。</p>
<img src="https://s2.loli.net/2022/05/31/1IF4TA2aVRfx8Ee.png" alt="image-20220531151537298" style="zoom:50%;" />

<p>那么如何画出2线？也就是SVM算法的步骤①。</p>
<p>把一条分割线平行地往两侧移动，直到擦到两边的样本。令平行线擦到的样本为支持向量（support vector），平行线的间隔称为间隔（margin），SVM就是要让间隔做最大的那一个分割线。</p>
<p>但该方法不唯一，与该线平行的线都是间隔最大的。为保证唯一性，应使这条线在两条平行线中央。</p>
<p>总结条件：① 该直线分开了两类 ② 该直线最大化间隔 ③该直线处于间隔的中间，到所有支持向量距离相等。</p>
<p>基于以下事实：</p>
<p>① 相同超平面</p>
<p>$$<br>w^Tx+b&#x3D;0 与\<br>(\alpha w^T)x+(ab)&#x3D;0是同一个超平面(\alpha \neq 0)<br>$$</p>
<p>② 点到直线&#x2F;面的距离公式</p>
<p>$$<br>d&#x3D;\frac{|w^Tx+b|}{||w||}<br>$$</p>
<p>我们要的就是最大化 margin 到 support vector 之间的距离！</p>
<p>据事实一，引出SVM最难理解的部分：用 a 去缩放 w 和 b。在 SVM 中，我们会发现我们会令支持向量到点的距离这一分式的分子是 1，为什么可以这么设呢？</p>
<p>因为对于对于一个 $$(w, b)$$，可以对齐进行任意的等比例放缩得到  $$(aw, ab)$$，二者所表示的超平面是不变的，但是会使得分子的大小变化，因此可以使得：</p>
<p>$$<br>|w^Tx_0+b|&#x3D;1, \ x_0为支持向量 \<br> |w^Tx_0+b|&gt;1, \  x_0非支持向量<br>$$</p>
<p>这样我们就大幅简化了要优化的对象。也即</p>
<p>$$<br>d&#x3D;\frac{|w^Tx+b|}{||w||} &#x3D; \frac{1}{||w||}<br>$$</p>
<p>因而问题转换为最小化 w 的模。实操中为方便求导定义作如下形式：</p>
<p>$$<br>最小化：\frac{1}{2}||w||^2 \<br>限制条件：y_i(w^TX_i+b) &gt;&#x3D; 1,(i&#x3D;1-N) \<br>||w||^2 &#x3D; \sum^{m}_{i&#x3D;1}w_i^2<br>$$</p>
<p>其中，$$y_i$$ 的作用是协调超平面的作用，同线性可分中的作用一样。上述的 1 可以改成别的整数，相当于放缩的时候采用了不同的尺度。</p>
<p>因而，SVM问题转为一个凸优化中的二次规划问题。</p>
<p>二次规划问题的定义：①目标函数(Objective Function)是二次项。②限制条件是一次项（这里的不等式就是一次项）。这样的问题要么无解，要么有唯一最小值。</p>
<p>已知凸优化问题，必有全局唯一的极值，可以用梯度下降解决。具体的解决方法，需学习《最优化》。</p>
<p>课后思考：</p>
<p>① 支持向量机的限制条件如果从大于等于1变成大于等于2，则(w, b)会变成(aw , ab) 。如果 Xi 和 w 是 M 维向量，那么 a 是多少？</p>
<p>② 证明在线性可分条件下，有且只有唯一一条直线满足 SVM 的三个条件。</p>
<h3 id="线性不可分的解法"><a href="#线性不可分的解法" class="headerlink" title="线性不可分的解法"></a>线性不可分的解法</h3><p>考虑线性不可分的情况，需要适当放松限制条件，否则以上问题无解。</p>
<p>基本思路有为为每个训练样本及其标签设置松弛变量（slack variable）δ。</p>
<p>因此，限制条件改写为：</p>
<p>$$<br>y_i(w^TX_i+b) &gt;&#x3D; 1-\delta_i,(i&#x3D;1-N)<br>$$</p>
<p>当然还要加入新的限制使得 $$\delta$$ 在一个合理范围内。最终，该问题改写为：</p>
<p>$$<br>最小化：\frac{1}{2}||w||^2 + C\sum^{N}<em>{i&#x3D;1}\delta_i\  或\ \frac{1}{2}||w||^2 + C\sum^{N}</em>{i&#x3D;1}\delta_i^2 \<br>限制条件： (1)\ \delta_i&gt;&#x3D;0,(i&#x3D;1-N)\<br>(2)\ y_i(w^TX_i+b) &gt;&#x3D; 1-\delta_i,(i&#x3D;1-N)<br>$$</p>
<p>比例因子C，起到平衡加法两侧的作用，是人为设定的超参数。实操中，要不断变化C，同时测试算法的效果，然后选个最好的。两个最小化形式都是二次型。C 设尽可能大，可以尽可能向线性的结果靠拢。</p>
<p>一个失败的情况：线性模型的表现力是不够的。</p>
<img src="https://s2.loli.net/2022/05/31/plhyxCJ6fLFswrd.png" alt="image-20220531154900234" style="zoom:50%;" />

<p>课后思考：</p>
<p>① 在这个例子中，你能否设计出一个这样的非线性变换，将这个分类问题转化为线性可分呢？</p>
<h3 id="非线性变换"><a href="#非线性变换" class="headerlink" title="非线性变换"></a>非线性变换</h3><p>针对线性模型表现力不够的情况，因而需要扩大可选函数范围。SVM中，会将特征空间把低维映射到高维，再使用线性超平面分类。</p>
<p>定理：在一个 M 维空间上随机取 N 个训练样本随机的对每个训练样本赋予标签 +1 或 -1，这些训练样本线性可分的概率为 P(M)，当 M 趋于无穷大时，P(M) &#x3D; 1。</p>
<p>构造映射 $$\varphi(x)$$ 便是关键。假设已知映射 $$\varphi(x)$$，则改为：</p>
<p>$$<br>最小化：\frac{1}{2}||w||^2 + C\sum^{N}<em>{i&#x3D;1}\delta_i\  或\ \frac{1}{2}||w||^2 + C\sum^{N}</em>{i&#x3D;1}\delta_i^2 \<br>限制条件： (1)\ \delta_i&gt;&#x3D;0,(i&#x3D;1-N)\<br>(2)\ y_i(w^T\varphi(X_i)+b) &gt;&#x3D; 1-\delta_i,(i&#x3D;1-N)<br>$$</p>
<p>此时，w 的维度和映射后的向量维度相同。解法是和低维完全类似的。</p>
<p>为研究 $$\varphi(x)$$ 的形式，引入核函数的概念。实操中我们不用知道 $$\varphi(x)$$ 的具体形式，取而代之的是核函数：</p>
<p>即对于任意两个向量，有</p>
<p>$$<br>K(X_1,X_2)&#x3D;\varphi(X_1)^T\varphi(X_2)<br>$$</p>
<p>那么仍然能通过一些技巧获得样本的类别，从而完成对样本类别的预测。具体通过为什么技巧将在之后描述。在此先举例说明核函数以及低维到高维的映射 $$\varphi(x)$$ 之间的相互关系。</p>
<p>假设 $$\varphi(x)$$ 是一个把二维向量映射为三维向量的映射：</p>
<p>$$<br>X&#x3D;[x_1,x_2]^T \<br>\phi(X)&#x3D;\phi([x_1,x_2]^T)&#x3D;[x_1^2,x_1x_2,x_2^2]<br>$$</p>
<p>假设有 X1 和 X2，那么核函数为：</p>
<p>$$<br>K(X_1,X_2)&#x3D;\phi(X_1)^T\phi(X_2) \<br>&#x3D;[x_{11}^2,x_{11}x_{12},x_{12}^2][x_{21}^2,x_{21}x_{22},x_{22}^2]^T \<br>&#x3D; x_{11}^2x_{21}^2+x_{11}x_{12}x_{21}x_{22}+x_{12}^2x_{22}^2<br>$$</p>
<p>反之，已知核函数 K 求 phi（x）。</p>
<p>$$<br>K(X_1,X_2)&#x3D;(x_{11}x_{21}+x_{12}x_{22}+1)^2 \<br>&#x3D; x_{11}^2x_{21}^2+x_{12}^2x_{22}^2+1+2x_{11}x_{21}x_{12}x_{22}+2x_{11}x_{21}+2x_{12}x_{22} \<br>&#x3D; \phi(X_1)^T\phi(X_2)<br>$$</p>
<p>根据定义和观察，</p>
<p>$$<br>\phi(X)&#x3D;\phi([x_1,x_2]^t) \<br>&#x3D; [x_1^2,x_2^2,1,\sqrt{2}x_1x_2,\sqrt{2}x_1,\sqrt{2}x_2]^T<br>$$</p>
<p>因而，核函数 K 和映射 phi 一一映射。但是 K 需要满足一定条件才可写作两个 phi 内积的形式。具体条件如下：（Mercer’s Theorem）</p>
<p>$$<br>K(X_1,X_2) 能写成 \phi(X_1)^T\phi(X_2)的充要条件：<br>$$</p>
<p>$$<br>① K(X_1,X_2)&#x3D;K(X_2,X_1)（交换性）\<br>② \forall C_i(i&#x3D; 1\sim N),\forall N有\sum^{N}<em>{i&#x3D;1}\sum^{N}</em>{j&#x3D;1}C_iC_jK(X_i,X_j) \ge0 （半正定性质）<br>$$</p>
<p>虽然无法知道 phi 的具体形式，但是可以知道 wx+b 的值，进而知道所属类别。</p>
<h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>具体研究已知 K 不知 phi 求 SVM 的优化问题。</p>
<p>原问题（Prime problem）</p>
<p>$$<br>最小化：f(w) \<br>限制条件：g_i(w) \le 0,i&#x3D;1\sim K \<br>h_i(w) &#x3D; 0,i&#x3D;1\sim K<br>$$</p>
<p>对偶问题（Dual problem）</p>
<p>$$<br>L(w,\alpha,\beta)&#x3D;f(w)+\sum^{K}<em>{i&#x3D;1}\alpha_ig_i(w)+\sum^{M}</em>{i&#x3D;1}\beta_ih_i(w) \<br>&#x3D;f(w)+\alpha^Tg(w)+\beta^Th(w)<br>$$</p>
<p>其中，</p>
<p>$$<br>\alpha &#x3D; [\alpha_1,\alpha_2,…,\alpha_K]^T \<br>\beta &#x3D; [\beta_1,\beta_2,…,\beta_M]^T \<br>g(w) &#x3D; [g_1(w),g_2(w),…,g_K(w)]^T \<br>h(w) &#x3D; [h_1(w),h_2(w),…,h_M(w)]^T<br>$$</p>
<p>在定义了 L 函数的基础上，定义对偶问题如下：遍历定义域里的 w，找到使得 L 最小的那个 w，同时把最小的这个函数值赋值给 theta 函数。</p>
<p>个人理解：先通过遍历 w 得到最小的 L。得到最小的 L 后就找到了对应的 w，此时 w 已知，alpha 和 beta 未知，因而得到 alpha 和 beta 的 theta 函数。之后再最大化这个函数。</p>
<img src="https://s2.loli.net/2022/05/31/OchJDWYZtAbgxas.png" alt="image-20220531162651917" style="zoom:50%;" />

<p>综合两个问题的定义，得到以下定理：</p>
<p>定理一：</p>
<img src="https://s2.loli.net/2022/06/01/VwJj5YStWBUAdru.png" alt="image-20220601212739070" style="zoom:50%;" />

<p>这个定理告诉我们原问题的解总是大于等于对偶问题的解。我们把 f(w*) - theta(alpha*, beta*) 定义为对偶差距（DUALITY GAP）。对偶差距显然大于等于0。</p>
<p>强对偶定理：</p>
<img src="https://s2.loli.net/2022/06/01/bFMSpKvQGjXTyBd.png" alt="image-20220601212922525" style="zoom:50%;" />

<p>简单点说，原问题的目标函数是凸函数，限制条件是线性函数，那么对偶差距为0。具体证明可以课后阅读。</p>
<p>根据定理一推出的不等式：</p>
<p>若 f(w*) &#x3D; theta(alpha*, beta*) （简单点说，就是原问题和对偶问题的解相等的时候），则根据定理一，显然可以推出，对于所有的 i&#x3D;1~K，要么 alpha_i &#x3D; 0，要么 g(w*) &#x3D; 0。这个条件就是 <strong>KKT 条件</strong>。</p>
<img src="https://s2.loli.net/2022/07/06/xWPny7HlMKkjC8A.webp" alt="tt" style="zoom: 80%;" />



<h3 id="最终求解"><a href="#最终求解" class="headerlink" title="最终求解"></a>最终求解</h3><p>将原问题转换为对偶问题，以完成问题的求解。</p>
<p>支持向量机的原问题满足强对偶定理。回顾 SVM 的优化问题：</p>
<img src="https://s2.loli.net/2022/05/31/oVqRixPIAESOwvZ.png" alt="image-20220531155717872" style="zoom:50%;" />

<p>结合原问题的定义，需要把前两个限制条件改成小于等于 0 的定义。限制条件取反，那么最小化中也要取反。</p>
<img src="https://s2.loli.net/2022/06/01/uI5UCYjaOpxh4qr.png" alt="image-20220601213714343" style="zoom:50%;" />

<p>两个限制条件都线性的，目标函数是凸的，满足强对偶定理。 SVM 中不存在 h(x) 的情况。因此，可以把 SVM 的对偶问题写作如下形式：</p>
<p><img src="https://s2.loli.net/2022/06/04/EQX89ehCZy6fgJM.png" alt="image-20220604100525102"></p>
<p>tips：对偶问题中的 w 指的是未知变量，此时，未知变量 w 包括 (w, sigma, beta)。求微分，得下式：</p>
<p><img src="https://s2.loli.net/2022/06/04/GvA6azXVfTZdjRn.png" alt="image-20220604101500136"></p>
<p>根据 ② 消去红框，根据 ③ 消去蓝框：</p>
<p><img src="https://s2.loli.net/2022/06/04/QoWi9dD48xhbeaK.png" alt="image-20220604101613674"></p>
<p>原式还剩三项：</p>
<p><img src="https://s2.loli.net/2022/06/04/uCDWijhQARV6azJ.png" alt="image-20220604101835441"></p>
<p><img src="https://s2.loli.net/2022/06/04/xSnw8R5I1odiZeH.png" alt="image-20220604101959039"></p>
<p>整理之后，化简为：</p>
<p><img src="https://s2.loli.net/2022/06/04/ZXldJepLO4mzkjh.png" alt="image-20220604102209717"></p>
<p>问题中，已知的是所有的 x，y 以及核函数 K。这是一个凸的问题，可以用 SMO 算法求解。</p>
<p>但化成这样后，还没完。这样求出了 alpha 还要求 omega 和 bias。</p>
<p><img src="https://s2.loli.net/2022/06/04/ImYC5iEnyph7X4R.png" alt="image-20220604102442932"></p>
<p>但是求 omega 岂不是又得知道映射函数？实则不用，因为实际上我们不需要知道 omega。考虑测试流程：</p>
<p>测试样本 x 输入，若 omega^T phi(x) + b&gt;&#x3D; 0 则 y&#x3D;+1，反之 y&#x3D;-1。</p>
<p>实际上， omega^T phi(x) &#x3D; sum_i_N alpha_i y_i K(xi, x)。又把 phi 化简掉了，只需要用核函数 K 去算就行。</p>
<p>接下来分析求 bias，先把 SVM 问题中的 KKT 条件列出：</p>
<p><img src="https://s2.loli.net/2022/06/04/en27UgKdAiz5ayw.png" alt="image-20220604103437775"></p>
<p>假定 alpha_i 都算出来了，那么一定能找出一个 alpha_i 是 0&lt;alpha_i&lt;C 的【？】。首先取一个 alpha_i 是 0&lt;alpha_i&lt;C 的，可得 beta_i &#x3D; c-alpha_i &gt; 0，可得 epsilon_i &#x3D; 0。有 alpha_i !&#x3D; 0 可得 ② 中后半式，根据该式求解 b：</p>
<p><img src="https://s2.loli.net/2022/06/04/Jr4OdHjYlGpCAiu.png" alt="image-20220604103518915"></p>
<p>在实际运算中，可以取所有满足条件 0&lt;alpha_i&lt;C 的 alpha_i，求出对应 b ，然后做平均。</p>
<p>总结如下：</p>
<img src="https://s2.loli.net/2022/06/04/8CQ5dEPj4wMyXAY.png" alt="image-20220604104117394" style="zoom:50%;" />

<p><img src="https://s2.loli.net/2022/06/04/ui7bZSk4YcTox6K.png" alt="image-20220604104219998"></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/machine-learning/" title="machine-learning">machine-learning </a><span class="leancloud_visitors"></span><span>About 3556 words, 11 min 51 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/07/06/machine-learning/lec2_%E6%A6%82%E7%8E%87%E5%88%86%E7%B1%BB%E6%B3%95/">probability-classification-method</a></h3></div><div class="post-content"><div class="card"><p><p>���ʷ��෨</p>
<p>�������⣺�� �����������࣬omega_1 �� omega_2���� ����ĳ�������� X��Ҫô�� X in omega_1��Ҫô�� X in omega_2��</p>
<p>�� P(omega_1 |X) �� P(omega_2 |X)��P(omega_1 |X) + P(omega_2 |X) &#x3D; 1��</p>
<p>�������⣺P(omega_1 |X) &gt; P(omega_2 |X) ���� X in omega_1��</p>
<p>���ݱ�Ҷ˹��ʽ��</p>
<p>P(omega_1 |X) &#x3D; P��X, omega_1) &#x2F; P(X) &#x3D; P��X|omega_1) P(omega_1)&#x2F; P(X) </p>
<p>P(omega_2 |X) &#x3D; P��X, omega_2) &#x2F; P(X) &#x3D; P��X|omega_2) P(omega_2)&#x2F; P(X) </p>
<p>Ҫ�Ƚ�P(omega_1 |X) &gt; P(omega_2 |X)��ֻ��Ҫ�Ƚ���ʽ�ķ��ӡ�</p>
<p>���У�P(omega_1) �� P(omega_2) ���� omega ��������ʡ�P��X|omega_1) �� P��X|omega_2) ���� X �� omega �ϵ��������ʣ�P(omega_1 |X) �� P(omega_2 |X) ���� X �� W �ϵĺ�����ʡ�</p>
<p>�˹����������������ʣ�����������ģ�� P(omega_1 |X) �� P(omega_2 |X)��������ˣ������Ա���Ҫ�ǳ���ע������ʡ�����ѵ��������ģ�ͣ�ѵ����ʱ���������忪�����ǲ��Ե�ʱ���һ�����ͻ���ֺܴ�����⡣Ҳ��������Ҫ�ڲ��Ժ�ѵ����ʱ��֤������������ǲ��ġ�ʵ��ʱ������һ�������������ҵĲ��裬��ԭ��Ҳ���������</p>
<p>���������ص㡣��һ������������ӣ�����֪��������ʣ���<strong>���������������һ��</strong>���ڴ�����£�����׼��</p>
<p>�� P��X|omega_1) &lt; P��X|omega_2) �� X in omega_2����֮ X in omega_1</p>
<p>��ι���  P��X|omega) ������˵����һ�� X_i in omega������� P��X|omega) �����������������ܶȹ������⡣</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/machine-learning/" title="machine-learning">machine-learning </a><span class="leancloud_visitors"></span><span>About 695 words, 2 min 19 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/07/06/machine-learning/lec3_%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1/">probability-density-estimation</a></h3></div><div class="post-content"><div class="card"><p><p>���ر�Ҷ˹��������Naive Bayesian Classifier��</p>
<p>������������ ���� X ��ÿ��ά�ȶ�����ɢ��</p>
<p>�� X ��ÿ��ά�ȶ��Ƕ����ģ�������أ�</p>
<p>�����и�Ӧ�ý������ʼ����࣬��һ���ļ���ֻ�����ࣨ�Ƿ��������ʼ�����</p>
<p>���룺һ���ʼ� d</p>
<p>�����d in c_1 �� d in c_2</p>
<p>ѵ������ {(d_i, y_I)}_{i&#x3D;1-N}��d&#x3D;{w1, w2, …, wn} ��ÿ���ʼ���������</p>
<p>ѧϰĿ�꣺P(d|c_1) �� P(d|c_2)</p>
<p>P(d|C) &#x3D; P({w1, w2, …, wn} | C)</p>
<p>������������������������������ �٣�w �����ﱻ����Ϊ���ʣ�������Ȼ�ܶ࣬��������Ŀ�����޵ģ���˿��Ա���ɢ��ʾ�������������� �ڣ���Ȼ���Ƕ����ģ���Ϊ�����뵥��֮����������ϵ�������������ʼ�������һ�򵥵���������Լ��� �ڳ�������һЩ��Ϊ���ӵı�������ʶ�𣬱㲻����ô����</p>
<p>P(d|C) &#x3D; P({w1, w2, …, wp} | C) &#x3D; [�۳� i in n]P(w_i|C)</p>
<p>P(w_i|C_j) &#x3D; count(w_i, c_j) &#x2F; [�ۼ�w in V]count(w, c_j)������ j&#x3D;1-2��</p>
<p>P(C_i) &#x3D; count(C_i) &#x2F; count(C)</p>
<p> ��P(d|c_1)P(c_1) &gt; P(d|c_2)P(c_2) �� d in c_1��</p>
<p>�����ܴ����������������һ������δ��ѵ�����г��ֹ�����ô P(d|c) [����cȡ�ĸ�] ���� 0��Ϊ��ֹ����������Ľ����㹫ʽ���£�</p>
<p>P(w_i|C_j) &#x3D; count(w_i, c_j) + 1&#x2F; [�ۼ�w in V]count(w, c_j) + |V|������ j&#x3D;1-2��</p>
<p>��˹�ܶȺ���</p>
<p>���� {x_i}_{i&#x3D;1-n} in C��X_i ��һά�����</p>
<p>$P(X|C) &#x3D; \frac{1}{\sqrt{2\pi \sigma}}e ^ {- \frac{(x-\mu)^2}{2\sigma^2}}$ </p>
<p>$\mu &#x3D; \frac{1}{N} \sum^{N}_{i&#x3D;1}X_i$</p>
<p>$\sigma^2&#x3D;\frac{1}{N-1}\sum^{N}_{i&#x3D;1}(X_i-\mu)^2$ [��ƫ����]</p>
<p>�����һά�����������֤����ά�������</p>
<p>$P(X|C)&#x3D;\frac{1}{\sqrt{(2\pi)^d |\sum|}}exp[-\frac{1}{2}(x-\mu)^T\sum^{-1}(x-\mu)]$</p>
<p>������� $\sum $ �� $\mu$�����ü�����Ȼ��������Ŀ�꺯����</p>
<p>$E(\mu, \sum)&#x3D;\sum^{N}_{i&#x3D;1}lnP(x_i|C)$</p>
<p>���ڼ��裺�� ���� {X_i}_{i&#x3D;1-N}  ����ͬ�ֲ�</p>
<p>�� �趨 $\mu$ ��$\sum$ ʹ���� {x_i} �ĸ������</p>
<p>���򣬾����֤���κ�ȥ�˽⡣</p>
<img src="https://s2.loli.net/2022/06/04/OLDuRB6bo7gFwHi.png" alt="image-20220604170701333" style="zoom:50%;" />

<p>������Ҫǿ�����㣬�����ʷ��෨Ҫ����ļ��㣺</p>
<p>�� ���� X �ĸ��ʷֲ��ľ�����ʽ��Ҳ������ P(X|C)�������������ʽ���У���һЩ���������������˹���ʷֲ���Ϊ $\mu, \sum$��</p>
<p>�� �ü��������Ȼ�������Ż�Ŀ�꺯����</p>
<p>�� �� �� �е��Ż����⣬��ô��������</p>
<p>��Ȼ�����ڸ�˹�����Ǹ�͹�ĺ���������ֵ����ȫ�����ֵ�������ڿ���ֱ����΢������������ںܶ���������㲻�����ģ�����ô���أ������ݶ��½��ȵȡ�</p>
<p>��˹���ģ��</p>
<p>��󣬾�������һ���㲻��������ֵ�����⡣Ҳ����ϸ�˹ģ�ͣ�Gaussian Mixture Model����</p>
<p><img src="https://s2.loli.net/2022/06/04/wR7JIZ2tYvSeybK.png" alt="image-20220604171707303"></p>
<p><img src="https://s2.loli.net/2022/06/04/1KW7LlMsoDGmIVY.png" alt="image-20220604172023016"></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/machine-learning/" title="machine-learning">machine-learning </a><span class="leancloud_visitors"></span><span>About 1252 words, 4 min 10 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/07/06/machine-learning/lec5_%E9%9A%90%E5%90%AB%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E8%BF%87%E7%A8%8B/">Hidden Markov Models</a></h3></div><div class="post-content"><div class="card"><p><p>���������ɷ�ģ�ͣ�Hidden Markov Models��HMM��</p>
<p>һ��Ӧ�õ�����������ʶ�𡣶���һ�����������ǵ������ǣ���֪����ô���������Σ���֪��ÿ��״̬��ʱ���ж೤����Ҳ��֪��ÿ�������ζ�Ӧ�����֡�</p>
<p>����ǰ������⣬һ�����ܵķ������� kmeans �����࣬������״̬�������е���֮����ģ���ش��Ĵ��ڣ���ʵ����������ô����ʵ���У����� ni shi shui��һ�㲻�Ƿֳ� ni �� shi �� shui���Ữ�ֵظ�ϸ��</p>
<p>�����������ɷ�ģ�ͣ��൱��˵���ʱ������ѭ����˵�ǵ�ʱ������ѭ��…</p>
<p><img src="https://s2.loli.net/2022/06/07/Jmsju18kPflFUcR.png" alt="image-20220607222833016"></p>
<p>һ�� HMM ������������ɣ�lambda &#x3D; {A, B, pi}</p>
<p><img src="https://s2.loli.net/2022/06/07/dsFzUgbTe1Yci3X.png" alt="image-20220607214649518"></p>
<p>Ϊ�˽�ģ���㣬��һ��ʱ��״ֻ̬��ǰһ��ʱ��״̬�йأ����������Ʒ�����������ǰ���״̬��</p>
<p>ÿ�����������ĸ��ʷֲ�һ����в�ͬ��GMMָ��˹���ģ�͡�b_j(O) ��ʾ�������� O ���� S_j �ĸ��ʡ�</p>
<p>���������壺����ֻ֪������� O�����ǲ�֪������״̬ Q��Q �Ǳ������� O ��ģ���Ҫ������������ġ�</p>
<p>�����������������⡣</p>
<p>��һ��ʶ�����⣨Evaluation�����ٸ����ӣ�����1-10������ʶ�𣬽���10��ģ�ͣ�����ÿ��ģ����һ��P��˭��P�󣬾�˵�����ĸ����֡�</p>
<p><img src="https://s2.loli.net/2022/06/08/Ra3siTuSQUoz8YN.png" alt="image-20220608144446756"></p>
<p>��Щ����Ϊʲô��Ҫ�� b ����� pi ����� O1 ��״̬�� q1����ô����ͨ�� b ����� O1 ���� q1 �ĸ��ʡ����ǵؼ���һ�㣬���� b �����ȷ�еطֱ� O1 ��״̬������Ӧ��״̬ q1������ 1���Ƕ�Ӧ��״̬������ 0����ô��ô�������� q1 ״̬��ʼ�Ŀ����� pi ��û�����壬�ʸ���� pi ��һ�� 0�������˵������һ��������������ʣ��������ܱ����ϳ�ĳһ����һЩ�ض��Ĵʡ�</p>
<p>���ǵ�һ�� b ��������� O1 ��״̬�����ϵĸ��ʷֲ���Ҳ���� O1 ���ڸ���״̬�ĸ���ֵ������ O1 ������ p1 ���� s1����ô�ڵ�ǰ���� O1 �������� s1 ״̬�����ĸ��ʾ��ǵ���״̬ s1 �ĸ��ʳ���p1��ͬ���ģ����ǵڶ��� b ����� O2 ������ p2 ���� s2����ô�ڵ�ǰ���� O2 �������� s2 ״̬�����ĸ��ʾ��ǵ���״̬ s2 �ĸ��ʳ��� p2��</p>
<p><strong>Ҳ���Ƕ���ĳ������ O��������� O ����ĳ��״̬�ĸ��ʣ��� O ����ĳ��״̬������Ȩ�أ��������뵽�����״̬�ĸ��ʡ�</strong></p>
<p>һ��ʼû�뵽 b ���ԭ�򣺰�����״̬������֪�ˡ���֪�����ȷʵû�� b ���Ϊ�ȼ��� 1��ͬʱҲû�� sum �������δ֪������£���Ҫ����ÿ������Ŀ����ԣ��ͻ��и��ʷֲ�������������֪������� 1��0��0��0 �ĸ��ʷֲ���</p>
<p><img src="https://s2.loli.net/2022/06/07/T3hABPGWLm7SpXu.png" alt="image-20220607221145394"></p>
<p>��Ȼ�����������⣬��ʽ�ӻ���̫�����ˣ����������⡪������󷨡�</p>
<p><img src="https://s2.loli.net/2022/06/08/vFnMfT4NgHGkeSw.png" alt="image-20220608144702781"></p>
<p>alpha_t(i) ����Ϊ�����������ۻ��� t ʱ��ʱ���Ѹ�ʱ�̵���״̬���� s_i �����ĸ��ʡ�</p>
<p>b_i(O_1) &#x3D; P(O_1|q_t&#x3D;s_i, lambda) ����Ϊ��O1 ����״̬������ s_i ������Ȩ�ء�</p>
<p><img src="https://s2.loli.net/2022/06/08/Uf1EphGoldsq7Dg.png" alt="image-20220608145551371"></p>
<p>�������Decoding����</p>
<p>����һ�Ǹ���ģ�ͺ������������ڵ�ǰģ�͵������ƥ��������������ĳ̶ȣ������Ǹ���ģ�ͺ����������������������������ƥ�����״̬���С�</p>
<p><img src="C:%5CUsers%5Cysc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220608151907284.png" alt="image-20220608151907284"></p>
<p>��������ά�ر��㷨��</p>
<p><img src="C:%5CUsers%5Cysc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220608152130883.png" alt="image-20220608152130883"></p>
<p><img src="C:%5CUsers%5Cysc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220608152611205.png" alt="image-20220608152611205"></p>
<p>ÿ��ʱ�䶼����ѡ p ��״̬�е�һ���������൱����ͼ����ÿ��ʱ���ѡһ��״̬��Ȼ�����һ��·����ѡ���Ӧ״̬�󣬼����Ӧ״̬�ļ�ֵ��</p>
<p>ÿ��ʱ��Σ�ÿ��������һʱ��ε����нڵ����ߣ�����ֵ���ڵ�ǰ�������ֵ�Լ�������ֵʱǰһ���������һ����������Ի��ݵõ�һ����õ�·�ߣ�Ҳ����һ������ E(Q)��</p>
<p>ά�ر��㷨���̣�</p>
<p><img src="C:%5CUsers%5Cysc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220608152629433.png" alt="image-20220608152629433"></p>
<p>���ϵõ������� E(Q)�����൱�ڶ��ڸ�ÿ������� O ����һ����ǩ��</p>
<p>�������������Ϊһ������ HMM ģ�ʹ��ǩ�Ĳ������������ѧϰ���������ô�����ı�ǩ������ȵ����磬�Զ�ͨ�� O ѧϰ�����ǩ���Ӷ��滻���й۲�� b �</p>
<p>����������ѵ�����⣨Learning����</p>
<p><img src="https://s2.loli.net/2022/06/08/sUVBmfRTdir8xvM.png" alt="image-20220608154357784"></p>
<p>��͹���������Ż����������������˼��㣺</p>
<p><img src="https://s2.loli.net/2022/06/08/RoAqE136Fvy5pNK.png" alt="image-20220608154429833"></p>
<p><img src="https://s2.loli.net/2022/06/08/7BkSH3PstWvzgqY.png" alt="image-20220608154711950"></p>
<p><img src="https://s2.loli.net/2022/06/08/2R4P7ajJx8KeTfI.png" alt="image-20220608154733259"></p>
<p>b ���󷨣�</p>
<p><img src="https://s2.loli.net/2022/06/08/uP9rFgNSbKDqoJL.png" alt="image-20220608154757287"></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/machine-learning/" title="machine-learning">machine-learning </a><span class="leancloud_visitors"></span><span>About 2051 words, 6 min 50 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/07/06/machine-learning/lec4_EM%E7%AE%97%E6%B3%95/">expectation-maximization-algorithm</a></h3></div><div class="post-content"><div class="card"><p><h2 id="EM��Expectation-Maximization���㷨"><a href="#EM��Expectation-Maximization���㷨" class="headerlink" title="EM��Expectation-Maximization���㷨"></a><center>EM��Expectation-Maximization���㷨</center></h2><h3 id="1-���"><a href="#1-���" class="headerlink" title="1. ���"></a>1. ���</h3><p>��ֲ���ֵ���㷨��ֻ��ĳһ��ֲ���ֵ����ɽ⡣</p>
<p>�ŵ㣺�� ����Ҫ���κβ��� �� ��̼�</p>
<p>���⣺�������֪��ÿһ����������ĸ���˹�ֲ�����ô�����ܹ����׵ع���ÿ����˹�ֲ��ľ�ֵ�ͷ�������������ǲ�֪��ÿһ����������ĸ���˹�ֲ�����������ƣ�EM�㷨��</p>
<h3 id="2-GMM-�е�-EM"><a href="#2-GMM-�е�-EM" class="headerlink" title="2. GMM �е� EM"></a>2. GMM �е� EM</h3><p>�� ������������裺Ҫô a. �����ÿһ����ķֲ�������Ҫô b. �������˹�ֲ��Ĳ���</p>
<p>�� b. Ϊ����Ȼ�������Ĺ�����Ȼ�������˹�ֲ��Ĳ�����</p>
<p>�� E-step��</p>
<p><img src="https://s2.loli.net/2022/06/06/Gysjb84E7Apgclx.png" alt="image-20220606100216870"></p>
<p>�� M-step��</p>
<p><img src="https://s2.loli.net/2022/06/06/2ascSdWmEr67wA9.png" alt="image-20220606100550644"></p>
<p>�� �ص� �ڣ�����ѭ����ֱ��������</p>
<h3 id="3-K-Means-�е�-EM"><a href="#3-K-Means-�е�-EM" class="headerlink" title="3. K-Means �е� EM"></a>3. K-Means �е� EM</h3><p>�ٿ���һ�� EM �㷨������ ���� K-means��</p>
<p>�޼ලѧϰ��һ�֡�</p>
<p>���⣺���� N ������ {X_i}_{i&#x3D;1-N}����� N ����������� {Z_i}_{i&#x3D;1-N}��</p>
<p><img src="https://s2.loli.net/2022/06/06/mb9ogI1siFK4Lln.png" alt="image-20220606101157744"></p>
<p>֤�� k-means �㷨��</p>
<p>���ȶ�������һ��Ŀ�꺯����</p>
<p><img src="https://s2.loli.net/2022/06/06/hJnb35HdoOpcmfj.png" alt="image-20220606101527303"></p>
<p>Ȼ�󿴵� �� ���������� �� ������ʹ�� E ��С��</p>
<p>�ٿ��ǵ� �� ���� ���ڴ������������</p>
<p><img src="https://s2.loli.net/2022/06/06/j7TQNYWmxbE4hAO.png" alt="image-20220606101830189"></p>
<p>��ˣ��� �� ���ľ�ֵ��������Ҳ���� E ��С�����ϣ��� E �½� 0���������һ�� ���� ʹ�� E �����½����� E һ��������</p>
<h3 id="4-EM-�㷨һ����ʽ"><a href="#4-EM-�㷨һ����ʽ" class="headerlink" title="4. EM �㷨һ����ʽ"></a>4. EM �㷨һ����ʽ</h3><p>�����������ӣ��ó� EM �㷨��һ����ʽ��������֪�����Ϸֲ���<br>$$<br>p(x,z;\theta)<br>$$<br>���У�x �ǹ۲쵽�ı�����z ��Ǳ�ڱ���������Ҫ������������µĶ��������Ȼ���ƣ�<br>$$<br>\theta &#x3D; argmax_{\theta}logp(x;\theta)\<br>p(x;\theta) &#x3D; \sum_{z}p(x,z;\theta)<br>$$<br>��˹���ģ���е�����������ÿ��������ĳ����˹�ֲ��ĸ���</p>
<p>K-Means �е�����������ÿ�����Ƿ�����ĳ������</p>
<p><img src="https://s2.loli.net/2022/06/07/UgaT2WLBPjD8cGk.png" alt="image-20220607200553293"></p>
<p>ͬ��ͬ���ȼ�</p>
<p>���� Jensen ����ʽ�Ƶ��������f(x) &#x3D; logx��E(x) &#x3D; log[] �������ڵĶ�������ô X �����Ǹ���ʽ��</p>
<p><img src="https://s2.loli.net/2022/06/07/s1lUNEP4jqkG5ST.png" alt="image-20220607201340238"></p>
<p>���һ������Ϊ�����½�ȼ��� E(theta)������������˵�ʽ���Ƶ���Ҳ����˵���ڵȼ۵�����£��������½������󻯶�����Ȼ�����ˡ�</p>
<p>���һ�е��Ƶ����£�</p>
<p><img src="https://s2.loli.net/2022/06/07/qpMyfvmV84D52jC.png" alt="image-20220607203857799"></p>
<p>ͨ�� E �����ҵ���ʹ�õȺų����� $Q_i(z^{(i)})$�������Ժ����ǾͿ������ E(f(x)) �ˣ�Ҳ���ǵȼ������ f(E(x))��</p>
<p>���������Ƶ����õ� EM �㷨��һ����ʽ��</p>
<p><img src="https://s2.loli.net/2022/06/07/dkWnjMyzvGBDwbI.png" alt="image-20220607203956530"></p>
<p>֮����֤��</p>
<p><img src="https://s2.loli.net/2022/06/07/XKRqbY4rVck8wJQ.png" alt="image-20220607205107298"></p>
<p>����������һ��� EM �㷨�� kmeans �㷨�Ĺ�����</p>
<p>z_i �Ķ��壺�� i �����ĸ����ࡣ</p>
<p>Ϊʲô p ��ô���壿</p>
<p><img src="https://s2.loli.net/2022/06/07/UigG9DXkeLtv5Zh.png" alt="image-20220607205447457"></p>
<p>���һ�е�ʽ����</p>
<p><img src="https://s2.loli.net/2022/06/07/y2CeMFlgcnTLkA6.png" alt="image-20220607210820263"></p>
<p>֮�������΢�֣�</p>
<p><img src="https://s2.loli.net/2022/06/07/blL2e59Ak3fDtRx.png" alt="image-20220607212116393"></p>
<p>�ܽ��ص㣺��ֵѡ�񲻺ûᵼ�²��õĽ�������������ֲ���ֵ��</p>
<p>�ο����ϣ�</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Matrix_cc/article/details/105266141">https://blog.csdn.net/Matrix_cc/article/details/105266141</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/machine-learning/" title="machine-learning">machine-learning </a><span class="leancloud_visitors"></span><span>About 1227 words, 4 min 5 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/07/06/data-structure-algorithms/2021-07-06-floyd/">floyd</a></h3></div><div class="post-content"><div class="card"><p><h3 id="Step-1-思路"><a href="#Step-1-思路" class="headerlink" title="Step 1. 思路"></a>Step 1. 思路</h3><p>假设图上的任意两个点，已知两点间的路径权值，如果在图中能够找到一个点, 使其成为两点间的桥点，并且构成的新路径值小于旧路径值。则新路比旧路更短，由此可以得到一个递推公式：</p>
<p><strong>d[u][v]&#x3D;min(d[u][v],d[u][k]+d[k][v])</strong></p>
<h3 id="Step-2-代码实现"><a href="#Step-2-代码实现" class="headerlink" title="Step 2. 代码实现"></a>Step 2. 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int k = 1; k &lt;= n; k++)</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		for (int j = 1; j &lt;= n; j++)</span><br><span class="line">			dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);</span><br></pre></td></tr></table></figure>



<h3 id="Step-3-潜在疑惑"><a href="#Step-3-潜在疑惑" class="headerlink" title="Step 3. 潜在疑惑"></a>Step 3. 潜在疑惑</h3><p>由于<code>d[i][k]</code>，<code>d[k][j]</code>在不断更新，而不是恒定的最小值，所以如何保证<code>d[i][j]</code>在最后一次更新的时候，<code>d[i][k]</code>，<code>d[k][j]</code>一定是最小的 ?</p>
<ol>
<li>令任意两点i和j之间的路径上可选择经过的结点集合中，桥点编号最大的是k，当k&#x3D;x的时候，<code>d[i][j]</code>得到最小值。</li>
<li>设i-x中的桥点编号最大的为x1 ,x-j中编号最大的为x2</li>
<li>易得x&gt;x1 ,x&gt;x2①</li>
<li>假设此时命题成立，则x&#x3D;$x_1$时，<code>d[i][x]</code>最小，x&#x3D;x2 时，<code>d[x][j]</code>最小</li>
<li>由此可以得到x&#x3D;k的时候<code>d[i][x]+d[x][j]</code>已经是最小了,那么<code>e[i][j]=min(e[i][j]，e[i][x]+e[x][j])</code>必然可以得到最小值</li>
</ol>
<h3 id="Step-4-原先的错误想法以及更正"><a href="#Step-4-原先的错误想法以及更正" class="headerlink" title="Step 4. 原先的错误想法以及更正"></a>Step 4. 原先的错误想法以及更正</h3><p>假设x1 &gt; k ，当 x &#x3D; k，由于<code>d[i][k]</code> 还未取得最小值, 故<code>d[i][k] + d[k][j]</code>并没有取到最大值。所以命题①错误？事实上因为i-j的桥点编号最大的必然是k，此时令 k &#x3D; x1 , 则 <code>d[i][k]</code>的桥点编号皆小于k, 故当 x &#x3D; k 时，<code>d[i][k]</code>和<code>d[k][j] </code> ，因此<code>f[i][j]</code>可以取到最大值。 当 x2 &gt; k 时同理。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/algorithm/" title="algorithm">algorithm </a><span class="leancloud_visitors"></span><span>About 510 words, 1 min 42 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/07/06/data-structure-algorithms/2021-07-06-fragmentary-knowledge/">some-tips</a></h3></div><div class="post-content"><div class="card"><p><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>+++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span> * <span class="number">1000</span> + <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> pr = <span class="number">-1</span>, <span class="type">int</span> dst = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	d[v] = dst;</span><br><span class="line">	p[v] = pr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> to : g[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (to != pr) &#123;</span><br><span class="line">			<span class="built_in">dfs</span>(to, v, dst + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		--x, --y;</span><br><span class="line">		g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (d[i] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			st.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(-d[i], i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> v = st.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">		v = p[v];</span><br><span class="line">		++ans;</span><br><span class="line">		<span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(-d[v], v));</span><br><span class="line">		<span class="keyword">if</span> (it != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			st.<span class="built_in">erase</span>(it);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> to : g[v]) &#123;</span><br><span class="line">			<span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(-d[to], to));</span><br><span class="line">			<span class="keyword">if</span> (it != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				st.<span class="built_in">erase</span>(it);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Memset"><a href="#Memset" class="headerlink" title="Memset"></a>Memset</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>memset 函数是内存赋值函数，用来给某一块内存空间进行赋值的。</p>
<p>原型为 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> v, <span class="type">size_t</span> n)</span></span>;  </span><br></pre></td></tr></table></figure>

<p>这里s可以是数组名，也可以是指向某一内在空间的指针；v为要填充的值；n为要填充的字节数； </p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>① 数组置0（通用）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br></pre></td></tr></table></figure>

<p>② 无符号整数组置最值</p>
<p>即每个字节置为 0xff</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>③ 有符号整数置最值（memset能达到的最值）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">0x80</span>,<span class="built_in">sizeof</span>(arr)); <span class="comment">//set int to -2139062144</span></span><br></pre></td></tr></table></figure>

<p>④ 有符号整数置-1</p>
<p>即每个字节变成 0xff（-1补码）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(dp));</span><br></pre></td></tr></table></figure>

<p>⑤ Double置最值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(arr,<span class="number">0x7F</span>,<span class="built_in">sizeof</span>(arr)); <span class="comment">//set double to 1.38242e+306</span></span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">0xFE</span>,<span class="built_in">sizeof</span>(arr)); <span class="comment">//set double to -5.31401e+303</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. House Robber</a></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">12</span></span><br><span class="line">Explanation: Rob house <span class="number">1</span> (money = <span class="number">2</span>), rob house <span class="number">3</span> (money = <span class="number">9</span>) <span class="keyword">and</span> rob house <span class="number">5</span> (money = <span class="number">1</span>).</span><br><span class="line">             Total amount you can rob = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12.</span></span><br></pre></td></tr></table></figure>

<p>动态转移方程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + nums[i]);</span><br><span class="line"><span class="comment">// 若不抢这家，那么本次最大值为上次最大值；反之为上上次最大值＋这次</span></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. Min Cost Climbing Stairs</a></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: cost = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: Cheapest is start on cost[<span class="number">0</span>], <span class="keyword">and</span> only step on <span class="number">1</span>s, skipping cost[<span class="number">3</span>].</span><br></pre></td></tr></table></figure>

<p>动态转移方程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>]);</span><br><span class="line"><span class="comment">// 到达i点有两种方案：要么从前一次过来，要么从前前一格过来</span></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. Maximum Subarray</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6.</span></span><br></pre></td></tr></table></figure>

<p>动态转移方程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = (dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> ? dp[i<span class="number">-1</span>] + nums[i] : nums[i])</span><br><span class="line"><span class="comment">//dp[i] 代表以元素 nums[i] 为结尾的连续子数组最大和。</span></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence/">392. Is Subsequence</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = <span class="string">&quot;abc&quot;</span>, t = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>动态转移方程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = (t[i] == s[dp[i<span class="number">-1</span>]] ? dp[i<span class="number">-1</span>]+<span class="number">1</span> : dp[i<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">// dp[i] 表示t的第i位已匹配至s的dp[i]位</span></span><br></pre></td></tr></table></figure>



<h4 id="经典dp-0-1背包"><a href="#经典dp-0-1背包" class="headerlink" title="经典dp 0-1背包"></a>经典dp 0-1背包</h4><p>给你一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span>, W = <span class="number">4</span></span><br><span class="line">wt = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">val = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><code>dp[i][w] </code>的定义如下：对于容量为<code>w</code>的背包，装<code>前i</code>个物品，可以装的最大价值。</p>
<p>① 若第i个物品的<code>wt[i] &gt; w</code>，那么一定不会拿取。则容量为<code>w</code>的包装<code>前i</code>个物品可得到的价值则为容量为<code>w的</code>包装<code>前i-1</code>个物品可得到的价值，即<code>dp[i][w] = dp[i-1][w]</code>。</p>
<p>② 若第i个物品的<code>wt[i] &lt;= w</code>，那么则有以下两种情况	</p>
<p>​	a.不拿。容量为<code>w</code>的包装<code>前i个</code>物品可得到的值则为容量为<code>w</code>的包装<code>前i-1</code>个物品可得到的价值，即<code>dp[i][w] = dp[i-1][w]。</code></p>
<p>​	b.拿走。容量为<code>w</code>的包装<code>前i个</code>物品可得到的值则为容量为<code>w-wt[i]</code>的包装<code>前i-1</code>个物品可得到的价值+<code>第i项物品的价值</code>，即 <code>dp[i][w] = dp[i - 1][w - wt[i-1]] + val[i-1]</code>。</p>
<p>二者取最优解即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; wt, vector&lt;<span class="type">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector 全填入 0，base case 已初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1048">P1048 采药</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/others/" title="others">others </a><span class="leancloud_visitors"></span><span>About 1100 words, 3 min 40 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/07/06/data-structure-algorithms/2021-07-06-graph-theory-algorithm-template/">graph-theory-template</a></h3></div><div class="post-content"><div class="card"><p><h3 id="Step-1-建图-DFS-x2F-BFS"><a href="#Step-1-建图-DFS-x2F-BFS" class="headerlink" title="Step 1. 建图 + DFS&#x2F;BFS"></a>Step 1. 建图 + DFS&#x2F;BFS</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5318">P5318 【深基18.例3】查找文献</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125; e[maxn * <span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> head[maxn], tot, vst[maxn];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; y)</span></span>&#123;  <span class="comment">//排序规则</span></span><br><span class="line">	<span class="keyword">if</span>(x.first == y.first)  <span class="comment">//v相同按u排序</span></span><br><span class="line">	<span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x.first &gt; y.first;  <span class="comment">//否则按v从大到小排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++tot].to = v;</span><br><span class="line">    e[tot].nxt = head[u];</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(rt);</span><br><span class="line">    vst[rt] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (!vst[v])&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                vst[v] = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;    </span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; rt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    vst[rt] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[rt]; i != <span class="number">-1</span>; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vst[v])&#123;</span><br><span class="line">            <span class="comment">//vst[v] = 1;</span></span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(tmp[i].first, tmp[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="built_in">sizeof</span>(vst));</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Step-2-建图-拓扑排序"><a href="#Step-2-建图-拓扑排序" class="headerlink" title="Step 2. 建图 + 拓扑排序"></a>Step 2. 建图 + 拓扑排序</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">80112002</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn*<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> head[maxn], tot, ans, indegree[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++tot].to = v;</span><br><span class="line">    e[tot].nxt = head[u];</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo_sort</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (head[u] == <span class="number">-1</span>) ans = (ans + cnt[u]) % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            cnt[v] = (cnt[v] + cnt[u]) % mod;</span><br><span class="line">            indegree[v]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> n, m, u, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        indegree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo_sort</span>(n);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/algorithm/" title="algorithm">algorithm </a><span class="leancloud_visitors"></span><span>About 494 words, 1 min 38 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/">Previous</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>